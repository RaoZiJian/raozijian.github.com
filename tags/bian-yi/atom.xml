<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 编译 | Ken_Rao's blog]]></title>
  <link href="http://RaoZiJian.github.io/tags/bian-yi/atom.xml" rel="self"/>
  <link href="http://RaoZiJian.github.io/"/>
  <updated>2014-08-29T10:42:43+08:00</updated>
  <id>http://RaoZiJian.github.io/</id>
  <author>
    <name><![CDATA[RaoZiJian]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[QA_List_1]]></title>
    <link href="http://RaoZiJian.github.io/blog/2014/08/29/qa-03/"/>
    <updated>2014-08-29T10:32:20+08:00</updated>
    <id>http://RaoZiJian.github.io/blog/2014/08/29/qa-03</id>
    <content type="html"><![CDATA[<h4>Question 1: Cocos2dx编译错误Symbol(s) not found for architecture armv7</h4>

<pre><code>使用版本：3.0，3.1，3.2
运行环境：Mac OS 10.9.3    
开发环境：Xcode 5.1
出现问题：Other Linker Flags中增加-ObjC选项会出现如下编译错误。

(null): "_GCControllerDidDisconnectNotification", referenced from:

(null): -[GCControllerConnectionEventHandler observerConnection:disconnection:] in libcocos2dx iOS.a(CCController-iOS.o)

(null): "_GCControllerDidConnectNotification", referenced from:

(null): -[GCControllerConnectionEventHandler observerConnection:disconnection:] in libcocos2dx iOS.a(CCController-iOS.o)

(null): "_OBJC_CLASS_$_GCController", referenced from:

(null): Objc-class-ref in libcocos2dx iOS.a(CCController-iOS.o)

(null): (maybe you meant: _OBJC_CLASS_$_GCControllerConnectionEventHandler)

(null): Symbol(s) not found for architecture armv7

(null): Linker command failed with exit code 1 (use -v to see invocation)
</code></pre>

<h4>Answer 1: 出现Symbol(s) not found for architecture armv7的错误警告，表示某些类没有被编译到动态库中；可能是对应文件不存在或没找到，或者是没有被加入到XCode工程中，先检查一下你的CCController-iOS.mm文件有没有问题。</h4>

<p><a href="http://www.cocoachina.com/bbs/read.php?tid=225796&amp;page=1#1039042">全文参考链接</a></p>

<hr />

<h4>Question 2: 序列帧动画占用的内存太大，如何使用schedule相似功能？</h4>

<h4>Answer 2: 序列帧动画的确是把所需要的纹理都加载到内存，然后开始播放的，这是用空间换时间的的方案。如果你觉得占用内存过大，那么使用schedule也是可以使实现相似的效果，但是你需要自己实现一套纹理管理机制，在调用所需要的纹理前加载它到内存，同时释放不需要的纹理。</h4>
]]></content>
  </entry>
  
</feed>
